Summary :
I. Installation instructions
II. Understanding the added scripts: Overview of the files.
III. Adding dialogues: understanding the PBS file.
IV.	Core scripts modifications
===============================================================================================
I. Installation instructions

-Drop the "Quest Log" folder in your plugin folder. Careful, this addon adds stuff to the savefile, so it will probably be incompatible with previous savefiles. I reccomend starting from a fresh file to mess with it.

-I have included a test map to showcase the resource's capabilities. If you want to use it to test it out, you need to include the content of the "testing purposes" folder in your game in some way. Add the map file or rewrite one of yours you don't care about (the whole thing only uses essentials assets). 

-The resource should have originally included a new type of PBS file to store the various reactions of the NPCs. However, since the plugin system doesn't play nice with that kind of thing, i've had to settle for moving the PBS file to an additionnal script. If you wish to re-enable the PBS file behavior by importing some of my modifications to your core script files, take a look at section IV.
 
II. Understanding the added scripts: Overview of the files.

So, let's have a look at the scripts that make up the meat of this resource. Most of these should have a more detailed step-by-step comments in
them, so I'll stick to a general overview.
It should look like this :
0-PBSFileWorkaround
001-ScriptOverrides
002-QuestLog
003-QuestLogDetail

"0-PBSFileWorkardound" is what I had to resort to to bypass the compilator issues. Instead of adding a new PBS file with it's own structure that gets compiled like the rest, this one just dumps the entire text in a script in it's compilated format and call it a day. Right now, it contains the compilated version of the demo file I've included. Feel free to wipe it out and start clean, as unless you re-enable the PBS file behavior, this is where you'll be adding the quests to the log.

You'll want to escape all special characters inside the strings of this thing, (#,\,",',among others), and the structure is an array off Quests, which themselves are arrays containing their completion state and title, along with an array of goals. So it's an array within an array within an array WITHIN AN ARRAY. Be sure not to trip yourself up with the formatting.

On the flipside, if you re-enable the PBS file system thing, the coma "," becomes a forbidden character in the content of the quest goals. It shouldn't be a big deal, but you've been warned.

example :
{
	[
		["QUEST A", "1", "false",
			[
				["1", "Quest Goal 1"],
				["0", "Quest Goal 2"]
			]
		],
		["QUEST X", "2", "true",
			[
				["2", "Quest Goal 1"]
			]
		]
	]
}


"001-ScriptOverrides" is where all of the overrides to existing functions, modules, classes and scripts of Essentials are located. You'll find a list below that goes more in detail in what changes I made. if you experiences other mod incompatibility problems, the culprit is probably one of those overrides not playing nice with another mod. 

"002-QuestLog" is where things get serious. This is the class that defines the quest submenu in the pokegear. not much to add here outside of the fact that line 31-32 is where you define the dimensions of the quest list, so you can make it take up a much bigger portion of the screen if you want to. The thing is a menu comprised of two tabs : main quests and sidequests. The game remembers which one you were on last time you opened the log and which quest you had on your pointer for each menu and stores them in game variables so it remembers theme even after saving and quitting the game. This should hopefully make it more pleasant to use for users.

Just. don't use the variables numbers for something else already. I took it safe and used variables 997,998 and 999 for this, so you SHOULD be safe, but if you already use them for something, you'll want to change the numbers to avoid any interference.

Quests are also sorted following a simple order : first ongoing quests, then undiscovered quests, and finally, completed quests. You can change the order of those by messing with the custom sort order line 152.

"003-QuestLogDetails" is where I define the individual quest window. this is where the individual goals of a quest are displayed. Similar to quests themselves, goals can have three states - undiscovered, in which case they're invisible so as to not spoil players, ongoing (orange), and finished (green). If a single screen isn't enough to display all goals, it can dynamically create additionnal windows by cycling left and right. I don't reccomend taking this too far, as this can induce slight lag on loading up the quest, and more simply, because too many goals cluttering a single quest probably isn't a good idea.

You'll notice a method called "updateQuestLog" here. Yeah. Since the quest log actually saves completion data along with the quests, updating it between versions isn't a trivial task, as it'd mean resetting the player's progress on quests. So this function exists to solve that problem. It duplicates the saved quest log, then replaces it by the one found in quests.dat and then iterates to put every quest goal it can match to the old quest log to put them back to their state before updating, effectively bringing over the player's progress into the new quest array. You can optionally specify a parameter as to where to start in the quest log. This is mostly for the case where you introduce your quest log over the course of an update and want to retroactively include quests in your game, but don't want to clutter returning player's quest log with empty quests they did already - just specify where to start and the function will only compile the quests coming after that. Although since essentials 19 doesn't like at all dealing with new save stuff, this specific point is kinda moot unless you find a way around it.

You'll also notice two methods, pbSetQuestGoal and pbGetQuestState. they exist to trim out the process of updating quests.

See, without this methods, you'd have to do something like this : 
=>quest= $QuestLog.detect { |q| q[0] == "Your Quest Name" }

this allows you to grab the quest you want to handle.

=>quest[3][0][0]="2" 

this one lets you manipulate the  completion flag of the first goal of the quest. You can change which goal you're interacting with by changing the first 0.

=>quest[1]="2"

This allows you to change the overall completion flag of the quest, if needed.

=> $scene.spriteset.addUserSprite(LocationWindow.new(_INTL("Quest Log updated [Your quest name] [status]\n")))
You can use this to call a pop-up notice indicating an update in the questlog. Be wary, no using this during dialogues, only after.

Aside from the fact this is kinda unwieldy, it's also the most basic operation you'll want to perform and it's already four different lines with a convoluted syntax.

So instead, those functions exist to solve your problmes. pbSetQuestGoal does pretty much everything you could want. It finds the quest based on the title (case insensitive), then a goal based either on it's index or on a string contained in the goal (case insensitive, will stop at the first result, so use if you have unique enough sentences to search for), the state to which you want to set the goals, and two optionnal parameters. 
The function will now update the quest goal to the state you have passed to it. If the quest was undiscovered at the time, the game will set it to discovered and notify the player accordingly, saving you the trouble of an additionnal call. 

pbSetQuestGoal("Our first Side quest",0,2). There. Done. You took a quest and set it's first goal to completed.

If you're switching the goal to completed and all other goals have also been completed (or the shouldcomplete parameter was set to true), it will also update the quest status to completed and notify the player accordingly.
Finally, if you've set the parameter "revealNextGoal" to true, the function will update the next Goal in the list and set it to discovered while you're at it. This allows you to complete a goal and reveal the next one in a single function call.

The getQuestState is the other half of this script. It allows you to easily find the current state of any goal within a quest, allowing you to use those as variables check whenever needed.

getQuestState("Apricorn collect",1)==1, for example, returns true or false depending on whether or not the goal was discovered.

===============================================================================================
III. Adding quests: understanding the PBS file.
Let's have a look at the file. Take a look at the PBS File Overlook.png that should be included in this folder.
 
So, topdown explanation: 
1)	#------------------- is how the code understands you're moving on to the next character reactions and must add his current object to the array. Insert it before moving on to the next character, and remember to add it at the end of the file.
2)	The line immediately after the separator is what the code will understand as the header of the quest. First, the title, definitely the thing you should use to differentiate the quests. Second, the default state of the quest. In a real situation, they'd prolly be all initialized at 0, but for the purpose of this resource i've initialized most of them at 1 so they're at least shown. Finally, true/false is whether or not the quest is a main quest (true) or a sidequest (false)
3)	Every line after that that's not the separator is an objective of the quest. First the state of the goal (0-hidden, 1-discovered, 2-completed), second a description of the goal.

There's no direct connection between completion of the goals and completion of the overall quest. This is done so you can have mutually exclusive objectives, "hidden" tasks, and other fringe cases likes this. 

Be careful with typos, as the game won't find the flag it'll be searching for if this happens.
4)	No, seriously, remember to add the section separator at the end of the file. Trust me on this, you are going to spend a couple of tests wondering why the hell is your message not loading after getting the deired outcome in the battle, only to realize you forgot that line, which means the code didn't even processed it/didn't added it to the array.
===============================================================================================
IV.	Core scripts modifications
Here, you'll find an overview of the ScriptOverride.rb file I made, with a numbered list of my additions to the code.

Game_Save Values

1: this is where we add the array of quests to the list of things to save, so the game can remember we still did all this stuff next time we load the game. (yeah, this DOES mean savefiles won't be compatible after you install this and will have to start over unless you figure a way to bypass this.)

PokemonPokegearScreen

2,3,4: In the pokegear class, we add a button for our quest log, which will call our custom class QuestLog when pressed.
###WARNING###
The changes below have been commented out due to not working properly with the plugin feature, as they add a PBS file to the list of files to compile. In order to re-enable those modifications and make the resource work as intended, you'll need to paste this changes in their respective scripts directly. You can also not do that and keep going with the PBSFileWorkaround script I made. A lot of design choices I made for this probably make less sense if you're gonna make it a script instead, but it should still work, so it's your call.

UI_Load

-Lines 220-222 - 5 : we add the quests.dat to the list of files to load while loading the game. I'm not actually sure it SHOULD be here anymore, I just know it used to and that it seems to be working so far. While you don't strictly NEED this to get the quest log to work for testing purposes, you are going to need it if you plan to seriously add it to a game you plan to update later.

Compiler

-Lines 728-731 - 6: We add the message indicating we're currently compiling this PBS File
-Lines 768-770 - 7 : We add quests.dat to the list of files to create after compiling the PBS file
-Lines 791-793 - 8 : Same deal as previously, except it's the text file this time.

Compiler_CompilePBS
-Lines 1610-1647 - 23 : Our custom compilation function for our PBS file.